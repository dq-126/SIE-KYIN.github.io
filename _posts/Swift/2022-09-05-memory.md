---
title: 스위프트의 메모리
categories:
  - SWIFT
excerpt: "스위프트에서 메모리 어떻게 관리하는 지 알자보자:)"
date: 2022-09-05
tags:
- iOS
- swift
---



# 개요

---

모든 언어에서 메모리 관리는 중요하다.

C/C++은 포인터로 직접 관리해주고 자바는 가비지컬렉터라는 친구가 해준다.

스위프트는 어떻게 하는지 알아보자


<br />
<br />

---

# 메모리 관리의 역사

---

코코아 환경에서 처음 도입한 메모리 관리 모델은 Manual Retain Release(MRR)이다.

Manual Reference Counting(MRC)라고도 부른다. MRC는 객체의 소유권을 기반으로 메모리를 관리한다.

모든 인스턴스는 하나 이상의 소유자가 있는 경우 메모리에 유지된다.

소유자는 메모리가 더이상 필요없는 경우 소유권을 포기하고 소유자가 하나도 없는 메모리는 해제된다.

MRC는 객체의 소유권을 관리하기 위해 Retain Count를 사용한다.

이 모델을 사용해서 프로그램을 개발한다면 retain, release, autorelease를 이용하여 인스턴스 소유권과 관련된 코드를 짜야한다.

이건 너무 어렵다.

그래서 애플은 Automatic Reference Counting(ARC)를 도입했다.

MRR과 동일한 참조 카운트 모델을 사용하지만 향상된 컴파일러가 메모리 관리 코드를 자동으로 추가한다.


<br />

---

## retain

---

인스턴스에 retain 메시지를 보내면 참조 카운트가 1 증가한다. 메세지를 보낸 곳에서 객체를 소유한다.

<br />

---

## release

---

인스턴스에 release 메시지를 보내면 참조 카운트가 1 감소한다. 메세지를 보낸 곳에서 객체를 포기한다.

<br />

---

## autorelease

---

autorelease 메시지를 보내면 현재 사용 중인 autorelease pool 블록의 실행이 종료되는 시점에 참조 카운트가 1 감소한다.

여기서 autorelease pool이란 autorelease 메시지를 받은 인스턴스가 해제되기 전까지 저장되는 공간이다.

autorelease pool이 없는데 autorelease 메시지를 보내면 메모리 누수가 된다.

그래서 모든 프로젝트는 메인 스레드에서 동작하는 기본 pool을 제공한다.

모든 스레드는 autorelease pool을 가지고 있다.

중요하지만 GUI가 아닌 것을 개발할 때나, 반복문에서 다수의 임시 객체를 생성할 때, 스레드를 직접 생성할 때를 제외하고는 건들일이 없다.

<br />
<br />

---

# ARC

---

컴파일러가 코드를 분석한 후 객체의 생명주기에 적합한 메모리 관리 코드를 추가하는 것을 의미한다.

WWDC 2011에서 발표했다.

가비지 컬렉터는 런타임에 주기적으로 메모리를 정리하지만 ARC는 컴파일 시점에 코드가 자동으로 추가된다.

따라서 런타임에 메모리 관리를 위한 오버헤드가 발생하지 않는다.

오버헤드란 함수를 호출할때 함수 내용이 아닌 함수를 호출하는데 들어가는 비용을 말한다. 꼭 함수가 아니다.

ARC는 인스턴수룰 생성할 때마다 객체에 대한 정보를 저장하는 별도의 메모리 공간을 생성한다.

이 공간에는 인스턴스의 타입 정보와 속성 값이 저장된다.

<br />
<br />

---

# 강한 참조

---

해제된 메모리에 접근하는 코드는 런타임 오류의 원인이 된다.

ARC는 이러한 문제를 방지하기 위해 객체를 참조하고 있는 속성, 상수, 변수를 추적한다.

활성화된 참조가 하나라도 있으면 인스턴스는 해제되지 않는다.

이를 위해서 새로 생성된 객체는 자신이 할당되는 속성, 상수, 변수와 강한 참조를 유지한다.

쉽게말해 인스턴스가 계속해서 메모리에 남아있게 해주는 것을 강한 참조라고 할 수 있다.

흔히 우리가 참조한다고 하면 다 강한 참조이다.

인스턴스에 nil을 넣으면 참조횟수가 감소한다.

```swift
class Person {
    let name = "kyujin"
    var car: Car?
}

class Car {
    var model: String
    var owner: Person?

    init(model: String) {
        self.model = model
    }
}

var person: Person? = Person() // person's cnt == 1
var car: Car? = Car(model: "sonata") // car's cnt == 1

person?.car = car // 2
car?.owner = person // 2

person?.car = nil // 1
car?.owner = nil // 1

person = nil // 0
car = nil // 0
```

위에 처럼 안에서부터 다 해제시켜줘야할 수가 있다. 이걸 Stong Reference Cycle이라고 한다.

이건 너무 귀찮다.

그래서 약한 참조가 있다. 알아보자

<br />
<br />

---

# 약한 참조

---

약한 참조는 자신이 참조하는 인스턴스의 참조 횟수를 증가시키지 않는다. 

해당 참조 구문 앞에 `weak`를 써주면 된다.

상수를 약한 참조 할 수는 없다. 약한참조는 항상 옵셔널이어야한다.

ARC는 Zeroing Weak Reference라고 하는 약한 참조 방식을 사용하는데

이 참조는 자신이 참조하고 있는 인스턴스가 해제될 때 자신의 값을 nil로 초기화한다.

